/*
 Copyright 2024 Qiniu Cloud (qiniu.com).

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package linters

import (
	"path/filepath"
	"regexp"
	"strings"

	"github.com/qiniu/x/log"
	"github.com/qiniu/x/xlog"
)

// Filters filters the lint errors.
func Filters(log *xlog.Logger, a Agent, linterResults map[string][]LinterOutput) (map[string][]LinterOutput, error) {
	linterResults = cleanLintResults(a.RepoDir, linterResults)
	results := filterByPRChanged(a.Provider, linterResults)
	results, err := filterByAutoGenerated(a, results)
	if err != nil {
		return nil, err
	}

	results = filterBySA5008(results)
	return results, nil
}

// LinterRelated checks if the linter is related to the PR.
// Each linter has a list of languages that it supports and the file extensions are used to determine
// whether the linter is related to the PR.
func LinterRelated(linterName string, a Agent) bool {
	exts := make(map[string]bool)
	for _, file := range a.Provider.GetFiles(nil) {
		ext := filepath.Ext(file)
		if ext == "" {
			continue
		}
		exts[ext] = true
	}
	return languageRelated(linterName, exts)
}

// cleanLintResults cleans the file path in lint results.
// It removes the workdir prefix from the file path.
func cleanLintResults(workdir string, lintResults map[string][]LinterOutput) map[string][]LinterOutput {
	cleanedResults := make(map[string][]LinterOutput)
	for file, linters := range lintResults {
		cleanedFile := strings.TrimPrefix(file, workdir+"/")
		cleanedResults[cleanedFile] = linters
	}
	return cleanedResults
}

// filterByPRChanged filters out the lint errors that are not related to the PR.
func filterByPRChanged(provider Provider, outputs map[string][]LinterOutput) map[string][]LinterOutput {
	result := make(map[string][]LinterOutput)
	for file, lintFileErrs := range outputs {
		for _, lintErr := range lintFileErrs {
			if provider.IsRelated(file, lintErr.Line, lintErr.StartLine) {
				result[file] = append(result[file], lintErr)
			}
		}
	}
	return result
}

// filterByAutoGenerated filters out the auto-generated files.
func filterByAutoGenerated(a Agent, linterResults map[string][]LinterOutput) (map[string][]LinterOutput, error) {
	var filesToIgnore []string
	for file := range linterResults {
		absPath := filepath.Join(a.LinterConfig.WorkDir, file)
		if isGenerated, err := isGeneratedFile(absPath); err != nil {
			log.Errorf("failed to check if file is generated: %v", err)
			continue
		} else {
			if isGenerated {
				log.Infof("ignore generated file: %s", file)
				filesToIgnore = append(filesToIgnore, file)
			}
		}
	}

	for _, file := range filesToIgnore {
		delete(linterResults, file)
	}

	return linterResults, nil
}

// special handling for staticcheck SA5008 (unknown JSON option error)
// Background:
//   - https://github.com/qiniu/reviewbot/issues/24
var tagRex = regexp.MustCompile(`unknown JSON option "(.*)" \(SA5008\)`)

func filterBySA5008(results map[string][]LinterOutput) map[string][]LinterOutput {
	finalResults := make(map[string][]LinterOutput)

	for file, linterResults := range results {
		var lintersCopy []LinterOutput
		for _, linter := range linterResults {
			matches := tagRex.FindStringSubmatch(linter.Message)
			if len(matches) == 2 && isGoZeroCustomTag(matches[1]) {
				log.Warnf("ignore this error: %v", linter.Message)
				continue
			}
			lintersCopy = append(lintersCopy, linter)
		}
		if len(lintersCopy) > 0 {
			finalResults[file] = lintersCopy
		}
	}

	return finalResults
}

// isGoZeroCustomTag checks if the tag is a go-zero custom tag.
// refer: https://go-zero.dev/en/docs/tutorials/go-zero/configuration/overview#tag-checksum-rule
const (
	goZeroDefaultOption  = "default"
	goZeroEnvOption      = "env"
	goZeroInheritOption  = "inherit"
	goZeroOptionalOption = "optional"
	goZeroOptionsOption  = "options"
	goZeroRangeOption    = "range"
)

// FIXME(CarlJi): this function is a temporary solution for go-zero custom tag, see [#24](https://github.com/qiniu/reviewbot/issues/24)
// expect to remove this function after staticcheck supports go-zero custom tag.
func isGoZeroCustomTag(jsonOption string) bool {
	var found bool
	switch {
	case strings.HasPrefix(jsonOption, goZeroDefaultOption):
		found = true
	case strings.HasPrefix(jsonOption, goZeroEnvOption):
		found = true
	case strings.HasPrefix(jsonOption, goZeroInheritOption):
		found = true
	case strings.HasPrefix(jsonOption, goZeroOptionalOption):
		found = true
	case strings.HasPrefix(jsonOption, goZeroOptionsOption):
		found = true
	case strings.HasPrefix(jsonOption, goZeroRangeOption):
		found = true
	}

	if found {
		log.Warnf("this tag %v seems belongs to go-zero, ignore it temporary, see [#24](https://github.com/qiniu/reviewbot/issues/24) for more information", jsonOption)
	}

	return found
}

func languageRelated(linterName string, exts map[string]bool) bool {
	langs := Languages(linterName)
	for _, language := range langs {
		if language == "*" || exts[language] {
			return true
		}
	}
	return false
}
