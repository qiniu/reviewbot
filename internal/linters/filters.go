package linters

import (
	"github.com/xanzy/go-gitlab"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/google/go-github/v57/github"
	"github.com/qiniu/x/log"
	"github.com/qiniu/x/xlog"
)

// Filters filters the lint errors.
func Filters(log *xlog.Logger, a Agent, linterResults map[string][]LinterOutput) (map[string][]LinterOutput, error) {
	linterResults = cleanLintResults(a.LinterConfig.WorkDir, linterResults)
	results, err := filterByPRChanged(linterResults, a.PullRequestChangedFiles)
	if err != nil {
		return nil, err
	}

	results, err = filterByAutoGenerated(a, results)
	if err != nil {
		return nil, err
	}

	results = filterBySA5008(results)

	return results, nil
}

func FiltersMerge(log *xlog.Logger, a Agent, linterResults map[string][]LinterOutput) (map[string][]LinterOutput, error) {
	linterResults = cleanLintResults(a.LinterConfig.WorkDir, linterResults)
	results, err := filterByMRChanged(linterResults, a.MergeRequestChangedFiles)
	if err != nil {
		return nil, err
	}

	results, err = filterByAutoGenerated(a, results)
	if err != nil {
		return nil, err
	}

	results = filterBySA5008(results)

	return results, nil
}

// LinterRelated checks if the linter is related to the PR.
// Each linter has a list of languages that it supports and the file extensions are used to determine
// whether the linter is related to the PR.
func LinterRelated(linterName string, a Agent) bool {
	exts := exts(a.PullRequestChangedFiles)
	return languageRelated(linterName, exts)
}
func LinterRelatedMr(linterName string, a Agent) bool {
	exts := extsMr(a.MergeRequestChangedFiles)
	return languageRelated(linterName, exts)
}
func LinterRelatedMergeFiles(linterName string, a Agent) bool {
	exts := extsMergeFile(a.MergeRequestChangedFiles)
	log.Infof("end extsMergeFile %v", exts)
	return languageRelated(linterName, exts)
}
func extsMergeFile(changes []*gitlab.MergeRequestDiff) map[string]bool {
	exts := make(map[string]bool)
	for _, change := range changes {
		log.Infof(change.NewPath)
		ext := filepath.Ext(change.NewPath)
		if ext == "" {
			continue
		}
		exts[ext] = true
	}
	return exts
}

// cleanLintResults cleans the file path in lint results.
// It removes the workdir prefix from the file path.
func cleanLintResults(workdir string, lintResults map[string][]LinterOutput) map[string][]LinterOutput {
	cleanedResults := make(map[string][]LinterOutput)
	for file, linters := range lintResults {
		cleanedFile := strings.TrimPrefix(file, workdir)
		cleanedResults[cleanedFile] = linters
	}
	return cleanedResults
}

// filterByPRChanged filters out the lint errors that are not related to the PR.
func filterByPRChanged(outputs map[string][]LinterOutput, commitFiles []*github.CommitFile) (map[string][]LinterOutput, error) {
	result := make(map[string][]LinterOutput)
	hunkChecker, err := NewGithubCommitFileHunkChecker(commitFiles)
	if err != nil {
		return nil, err
	}

	for file, lintFileErrs := range outputs {
		for _, lintErr := range lintFileErrs {
			if hunkChecker.InHunk(file, lintErr.Line, lintErr.StartLine) {
				result[file] = append(result[file], lintErr)
			}
		}
	}

	return result, nil
}

// filterByPRChanged filters out the lint errors that are not related to the PR.
func filterByMRChanged(outputs map[string][]LinterOutput, commitFiles []*gitlab.MergeRequestDiff) (map[string][]LinterOutput, error) {
	result := make(map[string][]LinterOutput)
	hunkChecker, err := NewGitLabCommitFileHunkChecker(commitFiles)
	if err != nil {
		return nil, err
	}

	for file, lintFileErrs := range outputs {
		for _, lintErr := range lintFileErrs {
			if hunkChecker.InHunk(file, lintErr.Line, lintErr.StartLine) {
				result[file] = append(result[file], lintErr)
			}
		}
	}

	return result, nil
}

// filterByAutoGenerated filters out the auto-generated files.
func filterByAutoGenerated(a Agent, linterResults map[string][]LinterOutput) (map[string][]LinterOutput, error) {
	var filesToIgnore []string
	for file := range linterResults {
		absPath := filepath.Join(a.LinterConfig.WorkDir, file)
		if isGenerated, err := isGeneratedFile(absPath); err != nil {
			log.Errorf("failed to check if file is generated: %v", err)
			continue
		} else {
			if isGenerated {
				log.Infof("ignore generated file: %s", file)
				filesToIgnore = append(filesToIgnore, file)
			}
		}
	}

	for _, file := range filesToIgnore {
		delete(linterResults, file)
	}

	return linterResults, nil
}

// special handling for staticcheck SA5008 (unknown JSON option error)
// Background:
//   - https://github.com/qiniu/reviewbot/issues/24
var tagRex = regexp.MustCompile(`unknown JSON option "(.*)" \(SA5008\)`)

func filterBySA5008(results map[string][]LinterOutput) map[string][]LinterOutput {
	finalResults := make(map[string][]LinterOutput)

	for file, linterResults := range results {
		var lintersCopy []LinterOutput
		for _, linter := range linterResults {
			matches := tagRex.FindStringSubmatch(linter.Message)
			if len(matches) == 2 && isGoZeroCustomTag(matches[1]) {
				log.Warnf("ignore this error: %v", linter.Message)
				continue
			}
			lintersCopy = append(lintersCopy, linter)
		}
		if len(lintersCopy) > 0 {
			finalResults[file] = lintersCopy
		}
	}

	return finalResults
}

// isGoZeroCustomTag checks if the tag is a go-zero custom tag.
// refer: https://go-zero.dev/en/docs/tutorials/go-zero/configuration/overview#tag-checksum-rule
const (
	goZeroDefaultOption  = "default"
	goZeroEnvOption      = "env"
	goZeroInheritOption  = "inherit"
	goZeroOptionalOption = "optional"
	goZeroOptionsOption  = "options"
	goZeroRangeOption    = "range"
)

// FIXME(CarlJi): this function is a temporary solution for go-zero custom tag, see [#24](https://github.com/qiniu/reviewbot/issues/24)
// expect to remove this function after staticcheck supports go-zero custom tag.
func isGoZeroCustomTag(jsonOption string) bool {
	var found bool
	switch {
	case strings.HasPrefix(jsonOption, goZeroDefaultOption):
		found = true
	case strings.HasPrefix(jsonOption, goZeroEnvOption):
		found = true
	case strings.HasPrefix(jsonOption, goZeroInheritOption):
		found = true
	case strings.HasPrefix(jsonOption, goZeroOptionalOption):
		found = true
	case strings.HasPrefix(jsonOption, goZeroOptionsOption):
		found = true
	case strings.HasPrefix(jsonOption, goZeroRangeOption):
		found = true
	}

	if found {
		log.Warnf("this tag %v seems belongs to go-zero, ignore it temporary, see [#24](https://github.com/qiniu/reviewbot/issues/24) for more information", jsonOption)
	}

	return found
}

// exts returns the file extensions of the changes.
// file extensions are used to determine whether the linter is related to the PR.
func exts(changes []*github.CommitFile) map[string]bool {
	exts := make(map[string]bool)
	for _, change := range changes {
		ext := filepath.Ext(change.GetFilename())
		if ext == "" {
			continue
		}
		exts[ext] = true
	}
	return exts
}
func extsMr(changes []*gitlab.MergeRequestDiff) map[string]bool {
	exts := make(map[string]bool)
	for _, change := range changes {
		ext := filepath.Ext(change.NewPath)
		if ext == "" {
			continue
		}
		exts[ext] = true
	}
	return exts
}

func languageRelated(linterName string, exts map[string]bool) bool {
	langs := Languages(linterName)
	for _, language := range langs {
		if language == "*" || exts[language] {
			return true
		}
	}
	return false
}
